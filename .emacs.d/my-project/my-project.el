;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Provide the ability to
;   Search up the folder tree starting at the pwd for a project file.
;   Perform a completing read on the list of strings in the project file which are
;   paths to important files in the project, then find-file on that path.
;
; Using something from the f.el lib by Johan Andersson johan.rejeep@gmail.com
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This is interesting
  ;http://www.emacswiki.org/emacs/ProjectBufferMode

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(require 'f)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;search parameters
  (defvar search-upward-start "./"
  "Used by defuns in my-project.el as a starting location
    for searching up the path for the project file")
  ;
  (defvar file-cache-name ".project_files.txt" "Name of project file")
  ;
  (defvar dir-cache-name ".project_dirs.txt" "Name of project file")
  ;
  (defvar file-cache-location nil
    "Result of searching up the tree looking for the project file, is a dir")
  ;
  (defvar full-path-to-files-cache nil
    "Result of searching up the tree looking for the project file,is a file")
  ;
  (defvar manual-cache-location nil
    "Where to start the creation of a project file, MTF.")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun find-file-from-cache ()
  "Choose a file to open from a list containing paths to files, generated by Ruby"
  (interactive)
  (find-project-file (get-full-path-to-files-cache)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun find-file-from-cache ()
  "Choose a file to open from a list containing paths to files, generated by Ruby"
  (interactive)
  ;
  (setq full-path-to-files-cache (get-full-path-to-files-cache))
  ;
  ;; (find-project-file
  ;;     full-path-to-files-cache file-cache-location))
  (find-project-file (get-full-path-to-files-cache) ))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun dired-from-cache ()
  "Choose a dir to open from a list containing paths to dirs, that was generated by Ruby"
  (interactive)
  ;
  (find-project-dirs (get-full-path-to-dirs-cache)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun open-from-cache (arg)
  (interactive "P")
  "Choose a file to open with find-file or with a prefix arg a dirertory to open with
   dired from a list containing paths to files or dirs, that was previously generated by
   Ruby"
  (interactive)

  (let (
        (icicle-expand-input-to-common-match 0)
        (icicle-default-value nil)

        )
      (if arg
      ;
        (dired-from-cache)
        (find-file-from-cache))
    ))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Programmatically insert files into Dired buffer
;; C-h f dired tells you the answer. Just pass to dired, as the DIRNAME argument, a
;; list that has as its car the Dired buffer name you want (any string) and as cdr
;; the list of file names you want listed in the buffer. Generally, you want to use
;; absolute file names. For example:
;;
;; (dired (list "My Dired Buffer Name*" ; The Dired buffer name "/usr/foo/file1.el"
;;              ; First file "/usr/bar/toto/some-file.c" ; Second file
;;              "/whatever/directory/" ; Third is a directory
;;              "/a/file/somewhere.zzz")) ; Fourth
;;
;; Depending on your platform, names of any nonexistent files and directories you
;; enter might be ignored (not listed), or might raise an error. The former happens
;; if you use ls-lisp.el (e.g. MS Windows). You can force the use of ls-lisp on any
;; platform, if you like (but ls-lisp has fewer ls options), by doing this:
;;
;; (setq ls-lisp-use-insert-directory-program nil) (require 'ls-lisp)
;;
;; If you use library Dired+ (dired+.el) then you can interactively choose files
;; and directories to list: just give dired a non-positive prefix argument (i.e.,
;; <= 0). You are then prompted repeatedly for the directories and file names you
;; want listed. You can use file-name wildcards (i.e., * for globbing), to include
;; the matching files and directories. Use C-g to end inputting.
;;
;; In other words, instead of listing a single directory, the Dired buffer can list
;; any number of directories and file names, which can even belong to different
;; directory trees.
;;
;; (A non-negative prefix arg (i.e., >= 0) prompts you for the ls listing
;; switches. So a zero prefix arg prompts you for both switches and files/dirs to
;; list: first the ls switches and then the files/dirs.)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;open dired on a list of files and folders
(when nil
  (dired-noselect
   (list  "blah1"
          "c:/Users/family/AppData/Roaming/.emacs.d/block-move/block-move.el"
          "c:/Users/family/AppData/Roaming/.emacs.d/my-project/my-project.el"
          "c:/Users/family/AppData/Roaming/.emacs.d/frame-win-setup/frame-win-setup.el")))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;open dired on this path
(when nil
  (dired-noselect "c:/Users/family/AppData/Roaming/.emacs.d/"))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun find-project-file (path-to-project-file)
  "project file selection"
  (interactive)
  ;
  (let ((pop-up-frames t ))
  ;
  ;need code to search up the path to this file
  ;
  ;http://stackoverflow.com/questions/20747190/read-from-a-file-into-a-emacs-lisp-list
  ;another way using f package (s-split "\n" (f-read "~/data.txt") t)
  (setq project-file-as-list (split-string
     (slurp path-to-project-file) "\n" t))
  ;
  (if ido-mode
    (setq parpath-to-selected-file (ido-completing-read "Choose a file: " project-file-as-list))
    (setq parpath-to-selected-file
          (let ((completion-ignore-case t))
            (icicle-completing-read "Choose a file: " project-file-as-list))))
  ;
  ;. (dot character) is put in by find, don't want it in the full hard path
  ;
  ; maybe manually put on a :top tag, then remeve it here, just
  ; before opening the file.
  ;
  (setq parpath-strip (s-chop-prefixes '(".") parpath-to-selected-file) )
  ;
  (setq file-to-open (concat (f-dirname path-to-project-file) parpath-strip))
  ;
  (find-file file-to-open)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun find-project-dirs (path-to-project-dirs)
  "project file selection"
  (interactive)
  ;need code to search up the path to this file
  ;
  ;http://stackoverflow.com/questions/20747190/read-from-a-file-into-a-emacs-lisp-list
  ;another way using f package (s-split "\n" (f-read "~/data.txt") t)
  (setq project-dirs-as-list (split-string
     (slurp path-to-project-dirs) "\n" t))
  ;
  (if ido-mode
    (setq parpath-to-selected-dir (ido-completing-read "Choose a dir: " project-dirs-as-list))
          (let ((completion-ignore-case t))
            (setq parpath-to-selected-dir (completing-read "Choose a dir: " project-dirs-as-list))))
  ;
  ;. (dot character) is put in by find, don't want it in the full hard path
  (setq parpath-strip (s-chop-prefixes '(".") parpath-to-selected-dir) )
  ;
  (setq dir-to-open (concat (f-dirname path-to-project-dirs) parpath-strip))
  ;
  (dired  dir-to-open))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ideas on running shell command then pop-to-buffer from
;www.jakemccrary.com/blog/2013/08/10/
;  emacs-capture-shell-command-output-in-temporary-buffer/
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun my-create-project-file (arg)
  "Run a shell command, put it's output in a a pop-up buffer, with any prefix arg
   prompt the user for the start directory"
  (interactive "P")
  ;
  ;when default-directory is set in any way, it becomes buffer local
  (if arg
    (setq manual-cache-location (my-project-read-directory))
    (setq manual-cache-location default-directory))
    ;
    (let ((default-directory manual-cache-location))
    (setq tempvar default-directory)
    (with-output-to-temp-buffer "*CREATE-PROJECT-FILE*"
      ;; (shell-command "ruby ~/mybin/create_project_file.rb"
      (shell-command "/home/ptgd73/mybin/findme.sh"
                       "*CREATE-PROJECT-FILE*"
                         "*Messages*")))
    ;
    (pop-to-buffer "*CREATE-PROJECT-FILE*"))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun my-project-read-directory ()
  (interactive)
  "Prompt emacs user for a directory to start the cache search,
     based on defun moccur-grep-read-directory from color-moccur.el"
  (let ((dir default-directory))
    (setq dir (read-file-name "Directory: " nil nil t))
    ;
    (if (and (file-exists-p dir) (file-directory-p  dir))
      ;T
      (setq dir (file-name-as-directory dir))
      ;F
      (progn
       (message "Not a dir")
       (setq dir nil)))
  ;
  dir))
;
;  (setq my-project-directory-to-start-creation (my-project-read-directory))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; using a lambda
; (setq file-cache-location
;    (f-traverse-upwards
;      (lambda (path) (f-exists? (f-expand "desktop.ini" path)))
;      search-upward-start))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun project-file-exists-p (path)
; The single argument "path" is passed by f-traverse-upwards
  (f-exists? (f-expand file-cache-name path)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun get-full-path-to-files-cache ()
  "return the path to project file"
  (setq file-cache-location
    ;if project-file-exists-p returns t, then returt the path passed to it
    (f-traverse-upwards
                        'project-file-exists-p
                             search-upward-start))
  ;
  (f-expand
     file-cache-name
       file-cache-location))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun get-full-path-to-dirs-cache ()
  "return the path to project file"
  (setq file-cache-location
    ;if project-file-exists-p returns t, then returt the path passed to it
    (f-traverse-upwards
                        'project-file-exists-p
                             search-upward-start))
  ;
  (f-expand
     dir-cache-name
       file-cache-location))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;how about calling Ruby using shell-command-to-string to get dir that contains the file
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun my-another-way ()
  (interactive)
  "Another way to do the same thing"
  ;This May have a regexp that stops it from going up thru certian folders like ~
  (locate-dominating-file default-directory "my-project.el"))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun show-path-to-project-file ()
  (interactive)
  "Show the path if it exists"
  ;; (if full-path-to-files-cache
  (if (setq full-path-to-files-cache (get-full-path-to-files-cache))
  (message full-path-to-files-cache)
  (message "Project file has nil value")))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define-key global-map "\C-xPs" 'show-path-to-project-file)
(define-key global-map "\C-xPc" 'find-file-from-cache)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;http://stackoverflow.com/questions/20747190/read-from-a-file-into-a-emacs-lisp-list
(defun slurp (f)
  (with-temp-buffer
    (insert-file-contents f)
    (buffer-substring-no-properties
       (point-min)
       (point-max))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ;http://stackoverflow.com/questions/20747190/read-from-a-file-into-a-emacs-lisp-list
;; (defun blah (arg)
;;  (eval arg))
;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; (blah (quote message "aoeu"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; started with something from http://ergoemacs.org/emacs/elisp_hash_table.html
; Lib for hash table (requires dash 2.12 : way newer than what I have now):
;  https://github.com/Wilfred/ht.el
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun playing-around ()
  (interactive)
  ;; creating a hash
  (setq myotherHash (make-hash-table :test 'equal))
  (puthash "joe" "19" myotherHash)
  (puthash "jane" "20" myotherHash)
  ;; get all keys
  (require 'subr-x)
  (hash-table-values myotherHash) ; ⇒ ("jane" "joe")
  ;
  ;completing read on keys
  ;; (message (completing-read ": " myotherHash)))
  ;completing read on values
  (message (completing-read ": " (hash-table-values myotherHash))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(message "Reached the end of my-project.el")
(provide 'my-project)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
